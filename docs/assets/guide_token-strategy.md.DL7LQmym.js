import{_ as s,c as t,o as a,ah as n}from"./chunks/framework.BxJchdQ1.js";const g=JSON.parse('{"title":"Token 策略分析","description":"","frontmatter":{},"headers":[],"relativePath":"guide/token-strategy.md","filePath":"guide/token-strategy.md","lastUpdated":1767481360000}'),l={name:"guide/token-strategy.md"};function e(o,i,r,h,k,d){return a(),t("div",null,[...i[0]||(i[0]=[n(`<h1 id="token-策略分析" tabindex="-1">Token 策略分析 <a class="header-anchor" href="#token-策略分析" aria-label="Permalink to &quot;Token 策略分析&quot;">​</a></h1><p>一句话：对比Token刷新和会话独立两种策略，推荐混合方案。</p><blockquote><p><strong>注意</strong>：框架已实现Token刷新功能，可通过 <code>useApp.php</code> 中的 <code>token.refresh</code> 配置项启用。</p><p>详见：<a href="./authentication.html#token-刷新机制">用户认证文档</a></p></blockquote><hr><h2 id="两种方案对比" tabindex="-1">两种方案对比 <a class="header-anchor" href="#两种方案对比" aria-label="Permalink to &quot;两种方案对比&quot;">​</a></h2><h3 id="方案1-token验证后生成新token-刷新token" tabindex="-1">方案1：Token验证后生成新Token（刷新Token） <a class="header-anchor" href="#方案1-token验证后生成新token-刷新token" aria-label="Permalink to &quot;方案1：Token验证后生成新Token（刷新Token）&quot;">​</a></h3><p><strong>工作原理：</strong></p><ul><li>每次Token验证成功后，自动生成新的Token</li><li>客户端需要更新本地存储的Token</li><li>旧Token可以立即失效或设置短暂宽限期</li></ul><p><strong>优点：</strong></p><ul><li><strong>安全性高</strong>：定期轮换Token，减少泄露风险</li><li><strong>检测异常使用</strong>：如果旧Token被使用，可以检测到异常</li><li><strong>自动续期</strong>：活跃用户无需重新登录</li><li><strong>简化管理</strong>：无需存储Token列表</li></ul><p><strong>缺点：</strong></p><ul><li><strong>客户端复杂度</strong>：需要处理Token刷新逻辑</li><li><strong>网络开销</strong>：每次验证都要生成新Token</li><li><strong>并发问题</strong>：多个请求同时验证可能导致Token冲突</li><li><strong>用户体验</strong>：如果客户端未及时更新，可能导致请求失败</li></ul><hr><h3 id="方案2-会话独立token-每个会话有独立的token" tabindex="-1">方案2：会话独立Token（每个会话有独立的Token） <a class="header-anchor" href="#方案2-会话独立token-每个会话有独立的token" aria-label="Permalink to &quot;方案2：会话独立Token（每个会话有独立的Token）&quot;">​</a></h3><p><strong>工作原理：</strong></p><ul><li>每个登录会话生成唯一的Token</li><li>Token与session_id绑定</li><li>Token存储在数据库或缓存中，可以单独管理</li></ul><p><strong>优点：</strong></p><ul><li><strong>会话追踪</strong>：可以追踪每个设备的登录状态</li><li><strong>精确控制</strong>：可以单独撤销某个会话的Token</li><li><strong>多设备支持</strong>：不同设备有独立Token，互不干扰</li><li><strong>客户端简单</strong>：Token固定，无需刷新逻辑</li></ul><p><strong>缺点：</strong></p><ul><li><strong>存储开销</strong>：需要存储Token列表，数据库或缓存</li><li><strong>管理复杂</strong>：需要定期清理过期Token</li><li><strong>性能影响</strong>：每次验证需要查询存储</li><li><strong>扩展性</strong>：大量并发用户时，存储压力大</li></ul><hr><h2 id="推荐方案-混合策略-会话独立加可选刷新" tabindex="-1">推荐方案：混合策略（会话独立加可选刷新） <a class="header-anchor" href="#推荐方案-混合策略-会话独立加可选刷新" aria-label="Permalink to &quot;推荐方案：混合策略（会话独立加可选刷新）&quot;">​</a></h2><p>结合两种方案的优点，推荐以下实现：</p><h3 id="核心设计" tabindex="-1">核心设计 <a class="header-anchor" href="#核心设计" aria-label="Permalink to &quot;核心设计&quot;">​</a></h3><ol><li><p><strong>会话独立Token</strong></p><ul><li>每个登录会话生成唯一Token</li><li>Token与<code>session_id</code>强绑定</li><li>Token存储在内存缓存中（Redis/Memcached）或数据库</li></ul></li><li><p><strong>可选刷新机制</strong></p><ul><li>配置项控制是否启用自动刷新</li><li>刷新时更新过期时间，不改变Token本身</li><li>支持Token续期延长有效期</li></ul></li><li><p><strong>Token管理</strong></p><ul><li>支持查看所有活跃Token</li><li>支持撤销特定Token</li><li>自动清理过期Token</li></ul></li></ol><h3 id="实现建议" tabindex="-1">实现建议 <a class="header-anchor" href="#实现建议" aria-label="Permalink to &quot;实现建议&quot;">​</a></h3><div class="language-php vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">php</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 配置选项</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;app.token&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;enabled&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;strategy&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;session_based&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &#39;session_based&#39; | &#39;refresh&#39;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;auto_refresh&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,        </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 是否自动刷新</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;refresh_threshold&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,     </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 剩余时间 &lt; 30% 时刷新</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;store&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;cache&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,              </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &#39;cache&#39; | &#39;database&#39;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;max_sessions&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,            </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 每个用户最大会话数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><hr><h2 id="方案选择建议" tabindex="-1">方案选择建议 <a class="header-anchor" href="#方案选择建议" aria-label="Permalink to &quot;方案选择建议&quot;">​</a></h2><h3 id="选择方案1-刷新token-的场景" tabindex="-1">选择方案1（刷新Token）的场景： <a class="header-anchor" href="#选择方案1-刷新token-的场景" aria-label="Permalink to &quot;选择方案1（刷新Token）的场景：&quot;">​</a></h3><ul><li>单设备应用（移动App）</li><li>对安全性要求极高</li><li>客户端可以很好地处理Token刷新</li><li>用户量不大，性能不是瓶颈</li></ul><h3 id="选择方案2-会话独立-的场景" tabindex="-1">选择方案2（会话独立）的场景： <a class="header-anchor" href="#选择方案2-会话独立-的场景" aria-label="Permalink to &quot;选择方案2（会话独立）的场景：&quot;">​</a></h3><ul><li>多设备/多浏览器支持</li><li>需要精确的会话管理</li><li>需要支持&quot;踢出设备&quot;功能</li><li>高并发场景，需要快速验证</li></ul><h3 id="选择混合方案-推荐-的场景" tabindex="-1">选择混合方案（推荐）的场景： <a class="header-anchor" href="#选择混合方案-推荐-的场景" aria-label="Permalink to &quot;选择混合方案（推荐）的场景：&quot;">​</a></h3><ul><li>需要平衡安全性和用户体验</li><li>支持多设备登录</li><li>需要灵活的Token管理</li><li>生产环境应用</li></ul><hr><h2 id="安全性对比" tabindex="-1">安全性对比 <a class="header-anchor" href="#安全性对比" aria-label="Permalink to &quot;安全性对比&quot;">​</a></h2><table tabindex="0"><thead><tr><th>特性</th><th>刷新Token</th><th>会话独立</th><th>混合方案</th></tr></thead><tbody><tr><td>泄露后风险</td><td>低（定期轮换）</td><td>中（可撤销）</td><td>低（可撤销加轮换）</td></tr><tr><td>会话劫持防护</td><td>高</td><td>高</td><td>高</td></tr><tr><td>多设备支持</td><td>中</td><td>高</td><td>高</td></tr><tr><td>实现复杂度</td><td>中</td><td>中</td><td>高</td></tr><tr><td>性能开销</td><td>中</td><td>中</td><td>中</td></tr></tbody></table><hr><h2 id="最终建议" tabindex="-1">最终建议 <a class="header-anchor" href="#最终建议" aria-label="Permalink to &quot;最终建议&quot;">​</a></h2><p><strong>推荐使用混合方案</strong>，原因：</p><ol><li><strong>灵活性</strong>：可以根据业务需求调整策略</li><li><strong>安全性</strong>：结合两种方案的优点</li><li><strong>可扩展性</strong>：未来可以轻松添加新功能</li><li><strong>用户体验</strong>：支持多设备，不会频繁要求重新登录</li></ol><p><strong>实现优先级：</strong></p><ol><li>先实现会话独立Token基础功能</li><li>再添加可选刷新机制增强功能</li><li>最后添加Token管理功能</li></ol>`,44)])])}const c=s(l,[["render",e]]);export{g as __pageData,c as default};
